#### 阻塞用户交互的因素

- 运行长耗时任务时候,发生的交互
- 关键渲染更新时

####  长耗时判断标准 > 50ms

#### 长任务的概念

- 日常开发中常见的长任务

  ```js
  // 假设fn执行的时间是100ms 那在fn执行的时候,主线程被占用,不能执行其他的任务,比如用户交互等,就会造成延迟.
  function fn(){} 
  // 假设将fn的执行拆解为3个函数, 调用的顺序为fn1() fn2() fn3() 在这3个任务运行的过程中,是可以插入执行一些用户交互的. 
  function fn1(){}
  function fn2(){}
  function fn3(){}
  // 但是下面的这个方法不行 all()执行时一个长任务 只有等all函数执行完成,主线程才能处理下一个任务.
  function all() {
    fn1();
    fn2();
    fn3();
  }
  
  ```

  

- 怎样的任务属于长任务

  - 一个函数执行属于一个新任务 多个函数在一个函数中执行 也属于一个任务 那多个顶级作用域下的函数执行 属于多任务执行吗?

#### 合理的拆分长任务

- 使用代码延迟任务执行

  before

  ```js
  function setHeight(){
    fn()
    fn2()
    fn3()
    fn4()
  }
  setHeight()的调用属于长任务
  ```

  after

  ```js
  function setHeight(){
    fn()
    fn2()
    fn3()
    setTimeout(fn4,0)
  }
  setTimeout 重新创建了一个异步任务, 即使delay时间设置为0,也是OK的.
  ```

- 使用 `async` `await` 

  - 一旦出现优先级较高的任务,就需要让主线程优先执行该任务.

  - 让步的概念 是主线程不执行任何函数调用, 空出来 , 让当前重要的程序先执行

    ```js
      function yeildFn() {
                return new Promise((resolve) => {
                    setTimeout(resolve, 0);
                })
        }
       async function fn2() {
                const arr = [getData, loop, print]
                for (let i = 0; i < arr.length; i++) {
                    const task = arr[i];
                    task()
                    await yeildFn();
                }
        }
    fn2()
    // 从控制台看 确实可以将一个长任务,通过这样的方式 拆解为小任务 从而可以在每个任务之间穿插一些其他的优先级高的任务.
    // navigator.scheduling.isInputPending()
    async function saveSettings () {
      // 函数队列
      const tasks = [    validateForm,    showSpinner,    saveToDatabase,    updateUI,    sendAnalytics  ];
      
      while (tasks.length > 0) {
        // 让步于用户输入
        if (navigator.scheduling.isInputPending()) {
          // 如果有用户输入在等待，则让步
          await yieldToMain();
        } else {
          // Shift the the task out of the queue:
          const task = tasks.shift();
    
          // Run the task:
          task();
        }
      }
    }
    ```

    