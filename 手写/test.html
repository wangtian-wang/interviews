<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script src="./deepClone.js"></script>
    <!-- <script src="./区间合并.js"></script> -->
    <!-- <script src="./call.apply.bind.js" type="text/javascript"></script> -->

    <!-- <script type="text/javascript">
      let arr = [86, 24, 64, 48];
      function insertSort(arr) {
        if (arr.length <= 1) return arr;
        for (let i = 1; i < arr.length; i++) {
          let j = i - 1;
          let cur = arr[i];
          while (j >= 0 && arr[j] > cur) {
            arr[j + 1] = arr[j];
            arr[j] = cur;
            j -= 1;
          }
        }
        return arr;
      }
      console.log(insertSort(arr));
    </script> -->
    <!--  <script>
      //   Promise.resolve(console.log(0))
      //     .then(() => {
      //       console.log(1);
      //       Promise.resolve(console.log(5))
      //         .then(() => console.log(3))
      //         .then(() => console.log(4))
      //         .then(() => console.log(6));
      //     })
      //     .then(() => console.log(2))
      //     .then(() => console.log(7));
      // 类似于这种嵌套的promise.resolve() 只有第一个promise.resolve.then的回调会立即执行
      //   Promise.resolve()
      //     .then(() => {
      //       Promise.resolve(
      //         Promise.resolve("0000").then((res) => {
      //           console.log(res);
      //         })
      //       )
      //         .then(() => {
      //           console.log(1);
      //         })
      //         .then(() => {
      //           console.log(2);
      //         });
      //     })
      //     .then((l) => {
      //       console.log("lallalal");
      //       Promise.resolve()
      //         .then((res) => {
      //           console.log(3);
      //         })
      //         .then(() => {
      //           console.log("4");
      //         });
      //     });
      function P() {}
      function C() {
        P.call(this);
      }
      C.prototype = new P();
      C.prototype.constructor = C;
      const c = new C();
      console.log(Function.prototype);
      const p = {};
      console.log(p.constructor === Object);

      function compose(fnArrays) {
        return (initValue) =>
          fnArrays.reduceRight((prev, cur) => cur(prev), initValue);
      }
      function asyncComponent(fnArrays) {
        return (initValue) =>
          fnArrays.reduceRight(
            (prev, cur) => prev.then((res) => cur(res)),
            Promise.resolve(Infinity)
          );
      }
    </script> -->
   
    <!--  
    程序啥时候 会清空微任务队列 Promise.resolve()的then的优先级高 ??
    还是说当调用栈里面没有可执行的代码时 promise.resolve.then 的优先级高呢?
    -->
  </body>
</html>
