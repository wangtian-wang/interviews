#### 严格模式 "use strict"

为啥会有严格模式

> 1: 为了保证代码运行安全
>
> 2: 提高编译器效率,提升运行速度

严格模式中的 this 指向

> 函数外指向 window
>
> 函数内指向 undefined

#### This 指向

> 看函数在哪里调用
>
> 指向方法所归属的对象

#### 箭头函数的 可以使用 new 吗?

> 剪头函数 没有自己的 this,super,prototype,不能使用 new 会报错

#### 数字超过最大限制如何处理

> 为啥会超出?
>
> js 数字使用 number 类型存储,number 类型是双精度 64 位浮点数,数值大的时候会超出存储范围
>
> 解决方法:
>
> 采用高精度算法,将这些数字拆开,拆成一位或者四位存储到一个数组中,用这个数组去表示一个数字,这样这个数字就被称为高精度数,高精度算法能够处理这样的高精度数字
>
> BigInt
>
> bigDecimal
>
> Json-bigint

#### 0.1 + 0.2 !== 0.3

> 计算机里面采用二进制存储数据 浮点数 -> 二进制
>
> js 中数字使用 Number 类型存储,number 是 64 位双精度浮点存储,即使整数也是如此 小数转换为二进制是无限不循环小数,计算机要存储这些数会有对尾部数字进行舍入,所以会有精度折损的问题
>
> 问题: number 类型存储与二进制存储之间的关系??
>
> 浮点数与定点数的区别
>
> 定点数(整数,小数)浮点数的区别，完全在于存储类型能存储的值的小数点位置是不是固定的。
>
> 浮点数则不一样，它分两部分记录，一部分是有效数字 x，另一部分记录的是，2 的几次幂 n。它的小数位随 n 的大小而浮动，所以叫 `浮点数`
>
> js 当中 最大安全整数 最大安全数 超出了 js 无法表示 js 中有新的类型 bigInt 来 解决大数相加精度丢失问题

#### 有了 tcp 协议为啥还要有 http 协议?

> ###### Tcp 协议可以让数据在两个端之间交换
>
> tcp 面向连接 可靠 字节流
>
> 字节流: 会产生粘包问题 无法区分 消息之间的界限 裸的 tcp 是不能直接使用的 需要加一些规则协议 来区分 消息界限
>
> 这些协议不一定是 htttp 协议 还有 rpc 协议
>
> ###### http 超文本传输协议,定义了数据交换的规则

#### let 的为啥会产生块级作用域

> let 的底层相当于立即执行的函数马上执行,形成了一个作用域,所以 let 创建的变量没有挂载到 window 上面

#### 为啥 array.prototype.slice.call()可以将类数组变为数组?

> slice()方法返回一个新的数组对象，这个对象是一个由 `begin` 和 `end` 决定的原数组的**浅拷贝**（包括 `begin`，不包括 `end`）。原始数组不会被改变

#### 获取数组中的最大值

> ```js
> Math.max(...arr);
> ```

4 面向对象编程 先有 `<font color="orange">`子类型 `</font>` 再有父类型

#### Es6 是怎样实现继承的

> ##### 通过关键字继承
>
> ##### extend 将子类型的原型对象继承为父类型的原型对象 保证子类可以使用父类原型上的方法
>
> ##### super 调用父类型的构造器 使得父类构造器中的 this 指向子类,初始化自有属性

#### async 的作用

##### 告诉主程序,这段函数内部的代码整体是异步执行的,不影响主程序的执行,函数内部是同步执行的

#### 箭头函数可以使用 bind()?

> 箭头函数不能使用 bind() 箭头函数的底层原理是 bind(),被 bind 绑定的函数,this 不能被修改

#### js 中创建对象的 10 种方式

> ##### 1: new object()
>
> ##### 2: 字面量
>
> ##### 3: 工厂函数 缺点: 本质还是 Object(),无法精准判断对象类型
>
> ```js
> function createObj(name, age) {
>   let o = {};
>   o.name = name;
>   o.age = age;
>   return o;
> }
> ```
>
> ##### 4: 构造函数
>
> ```js
> function Person(name, age) {
>   this.name = name;
>   this.age = age;
>   this.fn = function () {};
> }
> ```
>
> ##### 缺点: 构造函数中存在方法,反复创建,浪费内存
>
> ##### 5: 原型对象
>
> ```js
> function Person(name, age) {}
> Person.prototype.fn = "superxx";
> Person.prototype.fn = function fn() {};
> const xiaoming = new Person("xiaoming", 20);
> xiaoming.class = "三年级四班";
> ```
>
> ##### 6: 混合模式
>
> ```js
> function Person(name, age) {
>   this.name = name;
>   this.age = age;
> }
> Person.prototype.fn = function fn() {};
> const xiaoming = new Person("xiaoming", 20);
> xiaoming.class = "三年级四班";
> ```
>
> 缺点: 不符合封装思想
>
> ##### 7: 动态混合
>
> ```js
>     if 判断没有啥限制作用,在第一次实例化过后,fn属性就会添加到prototype上,成为原型属性,之类都会继承
>
>     function Person(name, age) {
>         this.name = name;
>         this.age = age;
>         if (Person.prototype.fn !== "undefined") {
>           Person.prototype.fn = function () {
>             console.log("fn exec---", this.name);
>           };
>         }
>       }
>       const xiaoming = new Person("xiaoming", 20);
>       const xiaohong = new Person("xiaohong", 20);
>
>       xiaoming.class = "三年级四班";
>       console.log(xiaoming.fn());
>       console.log(xiaohong.fn());
> ```
>
> ##### 8: 寄生构造函数
>
> ```js
> function Person(name, age) {
>   this.name = name;
>   this.age = age;
>   if (Person.prototype.fn !== "undefined") {
>     Person.prototype.fn = function () {
>       console.log("fn exec---", this.name);
>     };
>   }
> }
> function Child(name, age, className) {
>   const p = new Person("xiaoming", 20);
>   className && (p.class = className);
>   return p;
> }
> const xiaoming = new Child("xiaoming", 20, "三年级四班");
> const xiaohong = new Child("xiaohong", 20);
>
> console.log(xiaoming);
> console.log(xiaohong);
> ```
>
> ##### 9: 稳妥构造函数: 闭包,不用 this,不用 new 安全可靠
>
> ```js
> function Person(name, age) {
>   const p = {};
>   p.getName = function () {
>     return name;
>   };
>   p.getAge = function () {
>     return age;
>   };
>   return p;
> }
>
> const xiaoming = new Person("xiaoming", 20, "三年级四班");
>
> console.log(xiaoming);
> ```

#### console.log(1<2<3) ->true

> ```js
> console.log(1<2<3)
> console.log((1 <2 ) < 3) -> console.log(true <3) -> console.log(1 <3) ->true
> ```

#### Console.log(3>2>1) -> false

> ```js
> console.log( (3 > 2) >1) -> console.log(true > 1) -> console.log( 1 > 1) -> false
> ```

#### parseInt(string,radix)

##### 解析一个字符串,并返回指定的基数的十进制整数 ,返回值 : 给定的字符串中 被解析出来的整数 或者 NAN

> #### 当参数的类型不是 string 的时候,会将参数调用 String()转化为字符串
>
> String(0111111)
> '37449'
> String('0111111')
> '0111111'
>
> 注意: 当 radix 采用默认的 10 进制时
>
> 以 0 开头的数字会被 string 转化为字符串,再使用 10 进制表示这个字符串
>
> `parseInt(0111111) -> String(0111111) = 37449 -> parseInt(37449) -> 37339`

#### parseFloat(string)

> #### 解析一个参数,必要时先转为字符串,并返回一个浮点数 或者 NAN

#### null undefined 区别：

- null 设计之初是用来表示空值 但是 typeof null = object 作者觉得表示空值的不应该是个对象。所以设计了 undefined
- number（null） = 0 null 可以自动转化为 0
- null 是一个特殊关键字 不是标识符 不能被当做变量来使用和赋值 undefined 是全局的标识符 可以被赋值和当做变量来使用

解题思路 掌握举一反三的能力

关键词 :DP 数组(状态转移)以及下标的含义 /递推公式 /DP 数组如何初始化, 下标含义, 重点 /遍历数组顺序 /打印 DP 数组

vue3 的 react 对于嵌套对象的处理

当访问的属性是对象的时候,才做响应式处理

watch 里面直接监控一个对象 是观察不到 oldValue 和 newValue 的 因为 对象指向的是同一个引用地址

#### 如何跳出循环

> 1: foreach : throwError
>
> 2: for: break/ label ,break label/ throe error

#### bfc 是否脱离文档流

> 只要脱离文档流的都会形成 bfc

#### 使用 CSS 画五角星

> 链接: https://www.w3cschool.cn/article/29566632.html

#### 移动端适配

> 1: rem
>
> 2: 媒体查询
>
> 3: flexiable.js
>
> 4: vw/vh 兼容性需要注意

#### 1px 边框问题

> 1: 产生的原因
>
> 当出现了 dpr 这个概念后,css 中的 1px 不等于设备中的 1px(手机物理像素点), 当 dpr 为 2 时 1px = 2 个物理像素点
>
> 2: 解决方案:
>
> a: 当前项目比较旧 微元素 + transform scale
>
> b: 动态的 viewport + rem 布局设置
>
> c: vw(视口单位)

#### header

> header 标签中的请求未完成前, 浏览器是不会对 body 进行任何的解析和渲染, 用户只会看到 html 元素

#### devDependencies dependencies

> 对于业务代码
>
> 区别不大,我们打包时 依赖的是打包工具的模块分析规则 会去当前项目的 mode_module 下面寻找,只要找到即可
>
> 库开发者
>
> Dependencies : 在生产环境中使用
>
> 当安装一个包时, 该包的 Dependencies 也会被安装到项目中,但是 devDependencies 不会

#### pnpm 解决了 npm 的那些痛点

```js
npm@3
模块依赖关系:      扁平依赖关系
导致 :
a 模块可以访问自己不依赖的包
b: 扁平化模块的算法比较复杂
c: 一些包必须被复制到一个项目的node_module内部
存在的问题:
Node_module
-packageA
-packageA-a
-packageB

// Package.josn

{
	dependency: {
	 packageA : '0.3.3',
	 packageB: '0.3.3',
	}
}

Index.js
  import {xx} form -packageA-a

当前项目打包运行正常,上线也欧克
但是当packageA: '0.3.3' -> packageA: '0.3.3.beta'  并且packageA 不再依赖 packageA-a 或者升级 packageA-a

升级了依赖,重新打包该项目 就会发生错误,找不到 packageA-a

pnpm

所依赖的包,必须在package.json中声明

```

#### requestIdleCallback

> 用途: 维护一个队列 在浏览器空闲时间内执行 队列中的回调函数, 不会造成系统延迟,有助于确保浏览器的事件循环平稳运行
>
> 使用事项:
>
> 可以:
>
> 对于优先级不高的任务可以使用空闲回调
>
> 空闲回调执行的时间不要太长, 50ms 上限时间 即使超出了时间上限,浏览器也能正常运行
>
> 避免
>
> 1: 操作 DOM
>
> 2: 运行无法预测事件的任务
>
> 兼容性:
>
> 旧的浏览器不支持 需要回退到 setTimeout

#### Data Url

> 是前缀为 data: 指示数据类型的 MIME 类型的协议的 url, 它允许开发者向文档中签入小文件.
>
> 特点:
>
> base64 编码后,图片的体积会变大
>
> 编码后的图片不会被缓存下来,可以将 data url 写入到 css 文件中,伴随着 css 文件被缓存下来

#### HTML 的实体编码

```js
  < &gt...
```

#### 如何取消请求的发送

1. xhr -> XMLHttpRequest.abort()
2. fetch -> AbortController
3. axios->cancelToken

#### 什么是 URL 编码 (URL Encode)

1. encodeURI 用来编码**URI**，其不会编码保留字符：;,/?😡&=+$
2. encodeURIComponent 用来编码 URI**参数**，除了字符：A-Z a-z 0-9 - \_ . ! ~ \* ' ( )，都将会转义

#### + ~ 选择器区别

1. +选择器 -> 匹配紧邻的兄弟元素
2. ~选择器 -> 匹配所有的兄弟元素

#### 样式抖动

> 因为没有指定元素的具体宽高 或者指定的宽高和元素实际的大小有差异

#### position: sticky

> 浏览器会为有该属性的元素 创建一个层叠上下文 会相对于距离它最近的滚动元素和最近的块级元素定位

#### grid 布局与 flex 布局的区别

> Flex 布局是轴线布局，只能指定"项目"针对轴线的位置，可以看作是一维布局。 Grid 布局则是将容器划分成"行"和"列"，产生单元格，然后指定"项目所在"的单元格，可以看作是二维布局。 Grid 布局远比 Flex 布局强大

#### css 如何实现固定长宽比的元素

> aspect-ratio

#### flex

1. 1: flex basis flex 子元素在主轴方向上的初始大小

   当子项设置 width , basis 为 auto width 的优先级高

   当子项设置 width , basis 不为 auto 时 basis 的优先级高

2. 2: align-content 作用于副轴的多行元素,当副轴只有一行元素时 不起作用
3. 3: align-items 作用于副轴的单行元素

#### 网站设置字体时候,如何设置优先使用系统默认字体

```js
font-family: system-ui
```

#### CSS 避免命名冲突

```js
1: BEM 规范 嵌套太深 命名过长
2: css scoped: 会对当前组件下所有的元素生成唯一的属性或者类名,组件下的所有的css规则将携带唯一属性 实现作用域的命名保护
3: css module 对类名进行hash化
```

#### line-height

```js
改属性可以被继承
当设置为 rem em 1.5 100%  计算规则为 font-size * rem em 1.5 100%
```

#### 如何理解 MVVM

> vue 是一个实现了 mvvm 设计思想的前端框架, mvvm 框架 的核心思想是 将开发者从复杂的 dom 操作中解放出来,只需要去关注数据和 ui 层面的变化,所以任何实现了 mvvm 的框架 都会对 dom 操作进行高度的封装.
