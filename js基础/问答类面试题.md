#### 严格模式 "use strict"

为啥会有严格模式

> 1: 为了保证代码运行安全
>
> 2: 提高编译器效率,提升运行速度

严格模式中的 this 指向

> 函数外指向 window
>
> 函数内指向 undefined

#### This 指向

> 看函数在哪里调用
>
> 指向方法所归属的对象

#### 箭头函数的 可以使用 new 吗?

> 剪头函数 没有自己的 this,super,prototype,不能使用 new 会报错

#### 数字超过最大限制如何处理

> 为啥会超出?
>
> js 数字使用 number 类型存储,number 类型是双精度 64 位浮点数,数值大的时候会超出存储范围
>
> 解决方法:
>
> 采用高精度算法,将这些数字拆开,拆成一位或者四位存储到一个数组中,用这个数组去表示一个数字,这样这个数字就被称为高精度数,高精度算法能够处理这样的高精度数字
>
> BigInt
>
> bigDecimal
>
> Json-bigint

#### 0.1 + 0.2 !== 0.3

> 计算机里面采用二进制存储数据 浮点数 -> 二进制
>
> js 中数字使用 Number 类型存储,number 是 64 位双精度浮点存储,即使整数也是如此 小数转换为二进制是无限不循环小数,计算机要存储这些数会有对尾部数字进行舍入,所以会有精度折损的问题
>
> 问题: number 类型存储与二进制存储之间的关系??
>
> 浮点数与定点数的区别
>
> 定点数(整数,小数)浮点数的区别，完全在于存储类型能存储的值的小数点位置是不是固定的。
>
> 浮点数则不一样，它分两部分记录，一部分是有效数字 x，另一部分记录的是，2 的几次幂 n。它的小数位随 n 的大小而浮动，所以叫 `浮点数`
>
> js 当中 最大安全整数 最大安全数 超出了 js 无法表示 js 中有新的类型 bigInt 来 解决大数相加精度丢失问题

#### 有了 tcp 协议为啥还要有 http 协议?

> ###### Tcp 协议可以让数据在两个端之间交换
>
> tcp 面向连接 可靠 字节流
>
> 字节流: 会产生粘包问题 无法区分 消息之间的界限 裸的 tcp 是不能直接使用的 需要加一些规则协议 来区分 消息界限
>
> 这些协议不一定是 htttp 协议 还有 rpc 协议
>
> ###### http 超文本传输协议,定义了数据交换的规则

#### let 的为啥会产生块级作用域

> let 的底层相当于立即执行的函数马上执行,形成了一个作用域,所以 let 创建的变量没有挂载到 window 上面

#### 为啥 array.prototype.slice.call()可以将类数组变为数组?

> slice()方法返回一个新的数组对象，这个对象是一个由 `begin` 和 `end` 决定的原数组的**浅拷贝**（包括 `begin`，不包括 `end`）。原始数组不会被改变

#### 获取数组中的最大值

> ```js
> Math.max(...arr);
> ```

4 面向对象编程 先有 `<font color="orange">`子类型 `</font>` 再有父类型

#### Es6 是怎样实现继承的

> ##### 通过关键字继承
>
> ##### extend 将子类型的原型对象继承为父类型的原型对象 保证子类可以使用父类原型上的方法
>
> ##### super 调用父类型的构造器 使得父类构造器中的 this 指向子类,初始化自有属性

#### async 的作用

##### 告诉主程序,这段函数内部的代码整体是异步执行的,不影响主程序的执行,函数内部是同步执行的

#### 箭头函数可以使用 bind()?

> 箭头函数不能使用 bind() 箭头函数的底层原理是 bind(),被 bind 绑定的函数,this 不能被修改

#### js 中创建对象的 10 种方式

> ##### 1: new object()
>
> ##### 2: 字面量
>
> ##### 3: 工厂函数 缺点: 本质还是 Object(),无法精准判断对象类型
>
> ```js
> function createObj(name, age) {
>   let o = {};
>   o.name = name;
>   o.age = age;
>   return o;
> }
> ```
>
> ##### 4: 构造函数
>
> ```js
> function Person(name, age) {
>   this.name = name;
>   this.age = age;
>   this.fn = function () {};
> }
> ```
>
> ##### 缺点: 构造函数中存在方法,反复创建,浪费内存
>
> ##### 5: 原型对象
>
> ```js
> function Person(name, age) {}
> Person.prototype.fn = "superxx";
> Person.prototype.fn = function fn() {};
> const xiaoming = new Person("xiaoming", 20);
> xiaoming.class = "三年级四班";
> ```
>
> ##### 6: 混合模式
>
> ```js
> function Person(name, age) {
>   this.name = name;
>   this.age = age;
> }
> Person.prototype.fn = function fn() {};
> const xiaoming = new Person("xiaoming", 20);
> xiaoming.class = "三年级四班";
> ```
>
> 缺点: 不符合封装思想
>
> ##### 7: 动态混合
>
> ```js
>     if 判断没有啥限制作用,在第一次实例化过后,fn属性就会添加到prototype上,成为原型属性,之类都会继承
>
>     function Person(name, age) {
>         this.name = name;
>         this.age = age;
>         if (Person.prototype.fn !== "undefined") {
>           Person.prototype.fn = function () {
>             console.log("fn exec---", this.name);
>           };
>         }
>       }
>       const xiaoming = new Person("xiaoming", 20);
>       const xiaohong = new Person("xiaohong", 20);
>
>       xiaoming.class = "三年级四班";
>       console.log(xiaoming.fn());
>       console.log(xiaohong.fn());
> ```
>
> ##### 8: 寄生构造函数
>
> ```js
> function Person(name, age) {
>   this.name = name;
>   this.age = age;
>   if (Person.prototype.fn !== "undefined") {
>     Person.prototype.fn = function () {
>       console.log("fn exec---", this.name);
>     };
>   }
> }
> function Child(name, age, className) {
>   const p = new Person("xiaoming", 20);
>   className && (p.class = className);
>   return p;
> }
> const xiaoming = new Child("xiaoming", 20, "三年级四班");
> const xiaohong = new Child("xiaohong", 20);
>
> console.log(xiaoming);
> console.log(xiaohong);
> ```
>
> ##### 9: 稳妥构造函数: 闭包,不用 this,不用 new 安全可靠
>
> ```js
> function Person(name, age) {
>   const p = {};
>   p.getName = function () {
>     return name;
>   };
>   p.getAge = function () {
>     return age;
>   };
>   return p;
> }
>
> const xiaoming = new Person("xiaoming", 20, "三年级四班");
>
> console.log(xiaoming);
> ```

#### js 继承

1. es6 class extends 实现原型继承; super 调用父类的构造器 将 this 指向实例化的对象
2. 原型链继承

   ```js
   function P() {}
   function C() {}
   C.prototype = new p();
   缺点: 子类可能修改父类的属性(引用类型)或者方法;
   ```

3. 组合继承 原型链 + 构造函数

   ```js
   function P() {}
   function C( p.call(this)) {}
   C.prototype = new p();
   缺点: 父类的构造函数需要执行多次

   优化:
   function P() {}
   function C() {p.call(this)}
   C.prototype = Object.create(P.prototype)
   C.prototype.constructor = C;

   ```

4. 构造函数继承

   ```js
   function P() {}
   function C() {
     p.call(this);
   }
   缺点: 原型链上的属性和方法不能继承;
   ```

#### 构造函数[constructor] / Function.prototype= ƒ Function()

#### object array 等内置对象其实是 内置的构造函数

#### console.log(1<2<3) ->true

> ```js
> console.log(1<2<3)
> console.log((1 <2 ) < 3) -> console.log(true <3) -> console.log(1 <3) ->true
> ```

#### Console.log(3>2>1) -> false

> ```js
> console.log( (3 > 2) >1) -> console.log(true > 1) -> console.log( 1 > 1) -> false
> ```

#### parseInt(string,radix)

##### 解析一个字符串,并返回指定的基数的十进制整数 ,返回值 : 给定的字符串中 被解析出来的整数 或者 NAN

> #### 当参数的类型不是 string 的时候,会将参数调用 String()转化为字符串
>
> String(0111111)
> '37449'
> String('0111111')
> '0111111'
>
> 注意: 当 radix 采用默认的 10 进制时
>
> 以 0 开头的数字会被 string 转化为字符串,再使用 10 进制表示这个字符串
>
> `parseInt(0111111) -> String(0111111) = 37449 -> parseInt(37449) -> 37339`

#### parseFloat(string)

> #### 解析一个参数,必要时先转为字符串,并返回一个浮点数 或者 NAN

#### null undefined 区别：

- null 设计之初是用来表示空值 但是 typeof null = object 作者觉得表示空值的不应该是个对象。所以设计了 undefined
- number（null） = 0 null 可以自动转化为 0
- null 是一个特殊关键字 不是标识符 不能被当做变量来使用和赋值 undefined 是全局的标识符 可以被赋值和当做变量来使用

当访问的属性是对象的时候,才做响应式处理

watch 里面直接监控一个对象 是观察不到 oldValue 和 newValue 的 因为 对象指向的是同一个引用地址

#### 如何跳出循环

> 1: foreach : throwError
>
> 2: for: break/ label ,break label/ throe error

#### for in for of

> for in 遍历**任意对象**的可以**枚举**的属性
>
> for of 遍历**_可迭代对象_**定义的数据 比如类数组, map set 字符串

#### bfc 是否脱离文档流

> 只要脱离文档流的都会形成 bfc

#### 使用 CSS 画五角星

> 链接: https://www.w3cschool.cn/article/29566632.html

#### 移动端适配

> 1: rem + flex
>
> 2: 媒体查询
>
> 3: flexiable.js
>
> 4: vw/vh 兼容性需要注意

#### 1px 边框问题

> 1: 产生的原因
>
> 当出现了 dpr 这个概念后,css 中的 1px 不等于设备中的 1px(手机物理像素点), 当 dpr 为 2 时 1px = 2 个物理像素点
>
> 2: 解决方案:
>
> a: 当前项目比较旧 伪元素 + transform scale
>
> b: 动态的 viewport + rem 布局设置
>
> c: vw(视口单位)

#### header

> header 标签中的请求未完成前, 浏览器是不会对 body 进行任何的解析和渲染, 用户只会看到 html 元素

#### devDependencies dependencies

> 对于业务代码
>
> 区别不大,我们打包时 依赖的是打包工具的模块分析规则 会去当前项目的 mode_module 下面寻找,只要找到即可
>
> 库开发者
>
> Dependencies : 在生产环境中使用
>
> 当安装一个包时, 该包的 Dependencies 也会被安装到项目中,但是 devDependencies 不会

#### pnpm 解决了 npm 的那些痛点

```js
npm@3
模块依赖关系:      扁平依赖关系
导致 :
a 模块可以访问自己不依赖的包
b: 扁平化模块的算法比较复杂
c: 一些包必须被复制到一个项目的node_module内部
存在的问题:
Node_module
-packageA
-packageA-a
-packageB

// Package.josn

{
	dependency: {
	 packageA : '0.3.3',
	 packageB: '0.3.3',
	}
}

Index.js
  import {xx} form -packageA-a

当前项目打包运行正常,上线也欧克
但是当packageA: '0.3.3' -> packageA: '0.3.3.beta'  并且packageA 不再依赖 packageA-a 或者升级 packageA-a

升级了依赖,重新打包该项目 就会发生错误,找不到 packageA-a

pnpm

所依赖的包,必须在package.json中声明

```

#### requestIdleCallback

> 用途: 维护一个队列 在浏览器空闲时间内执行 队列中的回调函数, 不会造成系统延迟,有助于确保浏览器的事件循环平稳运行
>
> 使用事项:
>
> 可以:
>
> 对于优先级不高的任务可以使用空闲回调
>
> 空闲回调执行的时间不要太长, 50ms 上限时间 即使超出了时间上限,浏览器也能正常运行
>
> 避免
>
> 1: 操作 DOM
>
> 2: 运行无法预测事件的任务
>
> 兼容性:
>
> 旧的浏览器不支持 需要回退到 setTimeout

#### Data Url

> 是前缀为 data: 指示数据类型的 MIME 类型的协议的 url, 它允许开发者向文档中签入小文件.
>
> 特点:
>
> base64 编码后,图片的体积会变大
>
> 编码后的图片不会被缓存下来,可以将 data url 写入到 css 文件中,伴随着 css 文件被缓存下来

#### HTML 的实体编码

```js
  < &gt...
```

#### 如何取消请求的发送

1. xhr -> XMLHttpRequest.abort()
2. fetch -> AbortController
3. axios->cancelToken

#### 什么是 URL 编码 (URL Encode)

1. encodeURI 用来编码**URI**，其**不会编码保留字符**：;,/?😡&=+$
2. encodeURIComponent 用来编码 URI**参数**，除了字符：A-Z a-z 0-9 - \_ . ! ~ \* ' ( )，都将会转义

#### + ~ 选择器区别

1. +选择器 -> 匹配紧邻的兄弟元素
2. ~选择器 -> 匹配所有的兄弟元素

#### 样式抖动

> 因为没有指定元素的具体宽高 或者指定的宽高和元素实际的大小有差异

#### position: sticky

> 浏览器会为有该属性的元素 创建一个层叠上下文 会相对于距离它最近的滚动元素和最近的块级元素定位

#### grid 布局与 flex 布局的区别

> Flex 布局是轴线布局，只能指定"项目"针对轴线的位置，可以看作是一维布局。 Grid 布局则是将容器划分成"行"和"列"，产生单元格，然后指定"项目所在"的单元格，可以看作是二维布局。 Grid 布局远比 Flex 布局强大

#### css 如何实现固定长宽比的元素

> aspect-ratio

#### flex

1. 1: flex basis flex 子元素在主轴方向上的初始大小

   当子项设置 width , basis 为 auto width 的优先级高

   当子项设置 width , basis 不为 auto 时 basis 的优先级高

2. 2: align-content 作用于副轴的多行元素,当副轴只有一行元素时 不起作用
3. 3: align-items 作用于副轴的单行元素

#### 网站设置字体时候,如何设置优先使用系统默认字体

```js
font-family: system-ui
```

#### CSS 避免命名冲突

```js
1: BEM 规范 嵌套太深 命名过长
2: css scoped: 会对当前组件下所有的元素生成唯一的属性或者类名,组件下的所有的css规则将携带唯一属性 实现作用域的命名保护
3: css module 对类名进行hash化
```

#### line-height

```js
改属性可以被继承
当设置为 rem em 1.5 100%  计算规则为 font-size * rem em 1.5 100%
```

#### 如何理解 MVVM

> vue 是一个实现了 mvvm 设计思想的前端框架, mvvm 框架 的核心思想是 将开发者从复杂的 dom 操作中解放出来,只需要去关注数据和 ui 层面的变化,所以任何实现了 mvvm 的框架 都会对 dom 操作进行高度的封装.

#### vite webpack

vite

> 启动时 :vite 依赖 浏览器支持 esmodule 这一特性 ,按需加载文件 no boundler
>
> 浏览器发起请求以后，`dev server` 端会通过\*\* **`middlewares` 对请求做拦截，然后对源文件做** \*\*`resolve`、`load`、`transform`、`parse` 操作，然后再将转换以后的内容发送给浏览器。
>
> 开发语言 : go 编写 构建速度快
>
> 热更新: 精准的更新已经修改文件
>
> 生态: 勉强够用,有的功能需要自己开发
>
> 缺点:
>
> 在生产环境需要使用 rollup 打包
>
> 首屏性能
>
> 懒加载

webpack

> 启动时 webpack 构建流程比较耗时 boundler
>
> 开发语言 : JS 编写 构建速度慢
>
> 热更新: 随着项目变大,更新依赖的速度变慢
>
> 生态: 生态强大

#### TS

1. ts 是啥?
   1. ts 是 js 的超集,支持 es6 写法, 用于对变量类型,函数返回值等做一个类型约束, ts 不能直接允许在浏览器中,需要进行编译成 js 来运行.
2. ts 中的数据类型
   1. number string boolean Symbol Array
   2. Tuple 类似数组,但是 tuple 的元素可以是各种类型
   3. enum 枚举 命名的常量 数字类型枚举 字符串枚举 常量枚举
   4. never 表示那些永远不存在的值
   5. null undefined 是所有类型的子类型,当你指定 strictNullChecks 只能赋值给 void 或者它们自己本身.
   6. void 表示没有任何类型
   7. any 任意类型都可以 不能进行类型推倒
   8. unknown 不确定类型 能进行类型推倒
3. delcare 关键字
   1. 使用图片或者其他资源的时候,需要用 delcare 进行模块声明
   2. 声明全局的变量,函数等,使用的时候, 无需导入
   3. 引用第三方的库时.需要.d.ts 文件,否则会提示找不到该模块, 可以用 delcare 用来编写声明文件
4. ts 中的类型断言
   1. 1. 原理: 手动指定一个值的类型
      2. 使用场景: 不确定类型的时候就想访问一个类型确定的属性和方法，就需要【断言】,通过编译器的检查
      3. 方式
         <类型>变量
         变量 as 类型
5. ts 中的类型保护
   1. 1. typeof
      2. null
      3. in
      4. instanceof
      5. 字面量类型保护
      6. 使用定义的类型保护
   2. 通过一些关键字来缩小类型范围
6. interface type
   1. interface
      1. 1. 对于复杂数据类型 使用 interface
         2. 它能合并众多类型声明至一个类型声明
   2. type
      1. 简单数据类型使用 type
7. 交叉类型 联合类型
   1. 联合类型
      1. 使用 | 作为标记 ,类型可以是多种中的一种
   2. 交叉类型
      1. 使用 & 标记 类型必须满足 所有类型

#### script 标签的 crossorigin 属性

```js

crossorigin="anonymous" 请求当前script src属性 指定的资源 不发送用户凭据
<script src="https://example.com/example-framework.js" crossorigin="anonymous"></script>

crossorigin="use-credentials"  请求当前script src属性 指定的资源 需要用户凭据
<script src="https://example.com/example-framework.js" crossorigin="use-credentials"></script>

crossorigin=""  或者 crossorigin 请求当前script src属性 指定的资源 不需要用户凭据
```

1. 设置是否需要发送用户凭据
2. 在跨域的脚本发生错误的时候, window.onerror 可以获取到完整的错误信息
