#### 严格模式 "use strict"

为啥会有严格模式

> 1: 为了保证代码运行安全
>
> 2: 提高编译器效率,提升运行速度

严格模式中的 this 指向

> 函数外指向 window
>
> 函数内指向 undefined

#### This 指向

> 看函数在哪里调用
>
> 指向方法所归属的对象

#### 箭头函数的 可以使用 new 吗?

> 剪头函数 没有自己的 this,super,prototype,不能使用 new 会报错

#### 数字超过最大限制如何处理

> 为啥会超出?
>
>     js数字使用number类型存储,number类型是双精度64位浮点数,数值大的时候会超出
>
> 解决方法:
>
>     采用高精度算法,将这些数字拆开,拆成一位或者四位存储到一个数组中,用这个数组去表示一个数字,这样这个数字就被称为高精度数,高精度算法能够处理这样的高精度数字
>
> BigInt
>
> bigDecimal
>
> Json-bigint

#### 0.1 + 0.2 !== 0.3

> 计算机里面采用二进制存储数据 浮点数 -> 二进制
>
> js 中数字使用 Number 类型存储,number 是 64 位双精度浮点存储,即使整数也是如此 小数转换为二进制是无限不循环小数,计算机要存储这些数会有对尾部数字进行舍入,所以会有精度折损的问题
>
> 问题: number 类型存储与二进制存储之间的关系??
>
>     浮点数与定点数的区别
>
>     定点数(整数,小数)浮点数的区别，完全在于存储类型能存储的值的小数点位置是不是固定的。
>
> 浮点数则不一样，它分两部分记录，一部分是有效数字 x，另一部分记录的是，2 的几次幂 n。它的小数位随 n 的大小而浮动，所以叫 `浮点数`
>
> js 当中 最大安全整数 最大安全数 超出了 js 无法表示 js 中有新的类型 bigInt 来 解决大数相加精度丢失问题

#### 有了 tcp 协议为啥还要有 http 协议?

> ###### Tcp 协议可以让数据在两个端之间交换
>
>     tcp面向连接 可靠 字节流
>
>     字节流: 会产生粘包问题 无法区分 消息之间的界限 裸的tcp是不能直接使用的 需要加一些规则协议 来区分 消息界限
>
>     这些协议不一定是htttp 协议 还有rpc协议
>
> ###### http 超文本传输协议,定义了数据交换的规则

#### let 的为啥会产生块级作用域

> let 的底层相当于立即执行的函数马上执行,形成了一个作用域,所以 let 创建的变量没有挂载到 window 上面

#### 为啥 array.prototype.slice.call()可以将类数组变为数组?

> slice()方法返回一个新的数组对象，这个对象是一个由 `begin` 和 `end` 决定的原数组的**浅拷贝**（包括 `begin`，不包括 `end`）。原始数组不会被改变

#### 获取数组中的最大值

> ```js
> Math.max(...arr);
> ```

4 面向对象编程 先有`<font color="orange">`子类型`</font>` 再有父类型

#### Es6 是怎样实现继承的

> ##### 通过关键字继承
>
> ##### extend 将子类型的原型对象继承为父类型的原型对象 保证子类可以使用父类原型上的方法
>
> ##### super 调用父类型的构造器 使得父类构造器中的 this 指向子类,初始化自有属性

#### async 的作用

##### 告诉主程序,这段函数内部的代码整体是异步执行的,不影响主程序的执行,函数内部是同步执行的

#### 箭头函数可以使用 bind()?

> 箭头函数不能使用 bind() 箭头函数的底层原理是 bind(),被 bind 绑定的函数,this 不能被修改

#### js 中创建对象的 10 种方式

> ##### 1: new object()
>
> ##### 2: 字面量
>
> ##### 3: 工厂函数 缺点: 本质还是 Object(),无法精准判断对象类型
>
> ```js
> function createObj(name, age) {
>   let o = {};
>   o.name = name;
>   o.age = age;
>   return o;
> }
> ```
>
> ##### 4: 构造函数
>
> ```js
> function Person(name, age) {
>   this.name = name;
>   this.age = age;
>   this.fn = function () {};
> }
> ```
>
> ##### 缺点: 构造函数中存在方法,反复创建,浪费内存
>
> ##### 5: 原型对象
>
> ```js
> function Person(name, age) {}
> Person.prototype.fn = "superxx";
> Person.prototype.fn = function fn() {};
> const xiaoming = new Person("xiaoming", 20);
> xiaoming.class = "三年级四班";
> ```
>
> ##### 6: 混合模式
>
> ```js
> function Person(name, age) {
>   this.name = name;
>   this.age = age;
> }
> Person.prototype.fn = function fn() {};
> const xiaoming = new Person("xiaoming", 20);
> xiaoming.class = "三年级四班";
> ```
>
> 缺点: 不符合封装思想
>
> ##### 7: 动态混合
>
> ```js
>     if 判断没有啥限制作用,在第一次实例化过后,fn属性就会添加到prototype上,成为原型属性,之类都会继承
>
>     function Person(name, age) {
>         this.name = name;
>         this.age = age;
>         if (Person.prototype.fn !== "undefined") {
>           Person.prototype.fn = function () {
>             console.log("fn exec---", this.name);
>           };
>         }
>       }
>       const xiaoming = new Person("xiaoming", 20);
>       const xiaohong = new Person("xiaohong", 20);
>
>       xiaoming.class = "三年级四班";
>       console.log(xiaoming.fn());
>       console.log(xiaohong.fn());
> ```
>
> ##### 8: 寄生构造函数
>
> ```js
> function Person(name, age) {
>   this.name = name;
>   this.age = age;
>   if (Person.prototype.fn !== "undefined") {
>     Person.prototype.fn = function () {
>       console.log("fn exec---", this.name);
>     };
>   }
> }
> function Child(name, age, className) {
>   const p = new Person("xiaoming", 20);
>   className && (p.class = className);
>   return p;
> }
> const xiaoming = new Child("xiaoming", 20, "三年级四班");
> const xiaohong = new Child("xiaohong", 20);
>
> console.log(xiaoming);
> console.log(xiaohong);
> ```
>
> ##### 9: 稳妥构造函数: 闭包,不用 this,不用 new 安全可靠
>
> ```js
> function Person(name, age) {
>   const p = {};
>   p.getName = function () {
>     return name;
>   };
>   p.getAge = function () {
>     return age;
>   };
>   return p;
> }
>
> const xiaoming = new Person("xiaoming", 20, "三年级四班");
>
> console.log(xiaoming);
> ```

#### console.log(1<2<3) ->true

> ```js
> console.log(1<2<3)
> console.log((1 <2 ) < 3) -> console.log(true <3) -> console.log(1 <3) ->true
> ```

#### Console.log(3>2>1) -> false

> ```js
> console.log( (3 > 2) >1) -> console.log(true > 1) -> console.log( 1 > 1) -> false
> ```

#### parseInt(string,radix)

> #### 解析一个字符串,并返回指定的基数的十进制整数 ,返回值 : 给定的字符串中`<font color="orange">`被解析出来的整数`</font>` 或者 NAN
>
> #### 当参数的类型不是 string 的时候,会将参数调用 String()转化为字符串
>
> String(0111111)
> '37449'
> String('0111111')
> '0111111'
>
> 注意: 当 radix 采用默认的 10 进制时
>
> 以 0 开头的数字会被 string 转化为字符串,再使用 10 进制表示这个字符串
>
> `parseInt(0111111) -> String(0111111) = 37449 -> parseInt(37449) -> 37339`

#### parseFloat(string)

> #### 解析一个参数,必要时先转为字符串,并返回一个浮点数 或者 NAN

#### null undefined 区别：

- null 设计之初是用来表示空值 但是 typeof null = object 作者觉得表示空值的不应该是个对象。所以设计了 undefined
- number（null） = 0 null 可以自动转化为 0
- null 是一个特殊关键字 不是标识符 不能被当做变量来使用和赋值 undefined 是全局的标识符 可以被赋值和当做变量来使用

解题思路 掌握举一反三的能力

关键词 :DP 数组(状态转移)以及下标的含义 /递推公式 /DP 数组如何初始化, 下标含义, 重点 /遍历数组顺序 /打印 DP 数组

vue3 的 react 对于嵌套对象的处理

当访问的属性是对象的时候,才做响应式处理

watch 里面直接监控一个对象 是观察不到 oldValue 和 newValue 的 因为 对象指向的是同一个引用地址
