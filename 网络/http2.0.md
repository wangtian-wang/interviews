### HTTP2.0 版本与 HTTP1.0版本的关系

> HTTP2.0致力于突破上一代标准众所众知的性能限制,但是它是对1.x标准的扩展,而非替代.

### HTTP2.0 版本的主要变化 

1. 二进制帧 和 流

    http2.0的通信都在**一个连接**上完成, 这个连接可以承载任意数量的双向数据流(流是连接中的虚拟信道). 每个数据流, 以消息(请求,响应)的形式发送,而消息由一个或者多个帧组成, 帧可以乱序发送,然后根据每个帧首部的流标识, 重新组装.

   **核心**

   <font color="red">改变了数据的格式(二进制分帧的 核心 是在应用层做的改进) 和传输的方式(响应的多路复用)</font>

2. 多路复用

   在同一连接上,发送多个并发消息 -> 一个tcp链接 可以同时发送多个请求, 响应之间不会因为先后顺序阻塞. 

   [ 注 ]:

    HTTP1.x版本中, 多个并行请求意味着必须使用多个tcp连接,http1.x模型 保证每个连接每次只交付一个响应,多个响应必须排队, 会导致队首阻塞. HTTP2.0的二进制帧机制 , 解决了http1.x中存在的队首阻塞问题,也消除了 并行处理和发送请求以及响应时对多个连接的依赖. 速度更快, 开发简单,部署成本

3. 请求优先级

   优化帧的交错和传输顺序, 每个流都可以带有一个31比特的优先值. 有个这个值, 客户端和服务端就可以在处理不同的流时采用不同的策略.以最优的方式发送流,消息和帧. <font color="red">服务器根据流的优先级 , 优先将优先级高的帧发送给客户端</font>.

   [注]:浏览器的优先级分配:

     基于资源的类型,以及它们在页面中的位置,排定请求的优先次序. 发现资源时,立即分派请求,指定每个流的优先级,让服务器决定.

4. 服务端推送

     服务器可以向一个客户端发送多个响应, 除了最初请求的响应外,服务器还可以额外的推送资源,无需客户端明确的请求.客户端可以限定推送流的数量,或者把这个值设置为0 来禁止服务器推送.可以缓存推送过来的资源.

      主动推送的场景:

   在网页中嵌入过css js等,

      推送资源的要求

   ​       必须遵守同源策略.

   服务器如何向客户端推送资源

   ​    每个服务器的实现都用不同

   [注]:

   被服务器推送的资源,浏览器直接缓存,直接从本地的缓存中加载该资源.

5. 首部压缩

   压缩采用的算法: 索引表算法

   压缩表是怎样被维护的:

   - 客户端 -----> (首部表) <----服务端
   - 对于相同的数据,每次请求与响应不必再发送,     只编码和发送差异数据

   如何更新首部键值对

   - 1: 被追加到当前表的末尾
   - 2: 替换之前表中的值

    带来的性能提升:

   - 显著减少站点的页面加载时间

   

### 如何升级2.0

1. 客户端: 需要更新浏览器和网络库 | 现代浏览器都内置了高效的后台升级机制

2. 服务端: 需要升级   | 服务器和中间设备必须升级, 需要花费较长的时间 和 金钱.

3. HTTP1.x升级2.0

   <img src="/Users/wangtian/Desktop/interviews/网络/img/upgrade.png" style="zoom:80%;" />

   ```js
   客户端只能使用upgrade(流)机制,通过协调确定适当的协议.
   		case 1:  假设服务器不支持2.0 , 就立即返回http1.0的响应
   		case 2:   服务器支持2.0 , 服务器就会以1.1格式返回 101 switch protocol, 立即切换到http2.0并且使用新的二进制分帧协议返回响应.
   		无论那种情况,都不需要额外的往返,但是 双方必须发送 连接首部 ,来避免客户端,服务器,以及中间设备偶尔接收升级的请求却不理解新协议
   如果客户端因为自己保存或者通过其他手段(DNS ,手工配置)等获得了关于http2.0的支持信息,可以直接发送http2.0分帧,不必依赖upgrade/
   ```

4. https 升级http2.0

   ALPN (Application Layer Protocol Negotiation)来协商对于2.0的支持情况

