s 浏览器中的层分为 2 种, 渲染层和合成层

### 渲染层

##### 调试: 在开发者工具中看不到渲染层

#### 如何生成一个渲染层

层叠上下文 ???

简单理解:拥有 z-index 属性的定位元素会行程一个层叠上下文,一个生成层叠上下文的元素就生成了一个渲染层.

条件:1: document 元素

2: z-index 属性的定位元素(position: relative| absolute | stick |fixed )

3: opacity 非 1 的元素;

4: transform 非 none 的元素

5:弹性布局的子项(父元素是 display: flex | inline-flex),并且 z-index 不是 auto

6: filter 非 none 的元素

7: will-change: opacity | transform | filter

8: 需要裁剪的元素,overflow 非 visible

### 爆炸层

### 合成层 :

##### 调试 : 点击开发者工具的 layer 可以查看

#### 形成条件:只有特殊的渲染层才能提升为合成层

1: transform; translate(x,y);3D 变换,translateZ;

2: will-change: opacity | transform | filter

3: 对 opacity | transfrom | filter 应用了过渡和动画

4: video | canvas | iframe

##### 优点:

    浏览器分层是为了使用硬件加速,合成层的元素可以独立渲染(交给GPU-显卡处理,合成层的元素发生的回流,渲染都在这一层),比在主线程使用CPU效率高

缺点:

    当图层过多时，将会占用大量内存，尤其在移动端会造成卡顿，让优化适得其反

实践:

    提升渲染性能:
    
    1: 避免重排/重绘，直接进行合成
    
    2:注意隐式合成，给合成层一个较大的z-index值
    
    3: 减小合成层占用的内存，合成层的最大问题就是占用内存较多，而内存的占用和元素的尺寸是成正比的，如果要实现一个100X100的元素，可以给宽高都设置为10px，再使用transform:scale(10)放大10倍，这样占用的内存只有直接设置的1/100；

### 隐式合成

概念 :

    当出现一个合成层后,层级顺序`<font color="red">`高于 `</font>`它的堆叠元素就会发生隐式合成(形成了一个合成层)

举例:

    我们给C、D元素设置层级，z-index分别是3和4；又在C元素上使用3D变换，提升成了合成层。此时，层级高于它的D元素就发生了隐式合成，也变成了一个合成层。
    
    隐式合成出现的根本原是，元素发生了堆叠，浏览器为了保证最后的展示效果，不得不把层级顺序更高的元素拎出来盖在已有合成层上面。

副作用:

    页面中所有z-index高于它的节点全部被提升,合成层非常消耗内存和GPU,

解决方案:

    给合成层一个大的z-index,避免隐式合成

浏览器优化

    浏览器有优化机制,层压缩机制: 多个渲染层同一个合成层重叠时，会自动将他们压缩到一起，避免“层爆炸”带来的损耗。

### 问题:

#### 1: z-index大的元素一定在z-index小的元素的上面吗?

​	不一定,元素要加上定位后,才会生效,在当前的层叠上下文中比较才有意义

#### 2:父元素的z-index怎样覆盖子元素的z-index

   将子元素的z-index设置为负数



### 总结:

合成层中的层是:可以被认为是真正物理上的层，浏览器把它独立出来，单独拿给 GPU 处理

渲染层: 层叠上下文的“层”

一个合成层可以包含多个渲染层
