### 浏览器中的层分为 2 种, 渲染层和合成层

### 渲染层

#### 如何生成一个渲染层

层叠上下文

概念: HTML 元素沿着相对于用户的一条虚构的 Z 轴排开,层叠上下文就是对于这些 html 元素的一个三维构象,众多 HTML 元素基于元素属性按照优先顺序占据这个空间.

渲染层

概念:拥有 z-index 属性的定位元素会形成一个 `层叠上下文`,一个生成层叠上下文的元素就生成了一个 `渲染层. 所以调试台不能看到渲染层`

生成层叠上下文的条件

1: html 元素

2: z-index 属性的定位元素(position: relative| absolute ) 并且 z-index 不为 auto

z-index 属性的定位元素(position: stick |fixed )

3: opacity 非 1 的元素;

4: transform 非 none 的元素

5:flex grid 容器的 子元素(并且 z-index 不是 auto)

6: filter| opacity | transform | filter | clip-path | mask| perspective 非 none 的元素

7: will-change:

8: contain 属性的值为 layout paint

9: isolation :isolate

其子级层叠上下文的 `z-index` 值只在父级中才有意义。子级层叠上下文被自动视为父级层叠上下文的一个独立单元。

##### 子元素的层叠上下文会在父元素中被处理

### 爆炸层

### 合成层 :

##### 调试 : 点击开发者工具的 layer 可以查看

#### 形成条件:只有特殊的渲染层才能提升为合成层

1: transform; translate(x,y);3D 变换,translateZ;

2: will-change: opacity | transform | filter

3: 对 opacity | transfrom | filter 应用了过渡和动画

4: video | canvas | iframe

##### 优点:

    浏览器分层是为了使用硬件加速,合成层的元素可以独立渲染(交给GPU-显卡处理,合成层的元素发生的回流,渲染都在这一层),比在主线程使用CPU效率高

缺点:

    当图层过多时，将会占用大量内存，尤其在移动端会造成卡顿，让优化适得其反

实践:

    提升渲染性能:

    1: 避免重排/重绘，直接进行合成

    2:注意隐式合成，给合成层一个较大的z-index值

    3: 减小合成层占用的内存，合成层的最大问题就是占用内存较多，而内存的占用和元素的尺寸是成正比的，如果要实现一个100X100的元素，可以给宽高都设置为10px，再使用transform:scale(10)放大10倍，这样占用的内存只有直接设置的1/100；

### 隐式合成

概念 :

    当出现一个合成层后,层级顺序`<font color="red">`高于 `</font>`它的堆叠元素就会发生隐式合成(形成了一个合成层)

举例:

    我们给C、D元素设置层级，z-index分别是3和4；又在C元素上使用3D变换，提升成了合成层。此时，层级高于它的D元素就发生了隐式合成，也变成了一个合成层。

    隐式合成出现的根本原是，元素发生了堆叠，浏览器为了保证最后的展示效果，不得不把层级顺序更高的元素拎出来盖在已有合成层上面。

副作用:

    页面中所有z-index高于它的节点全部被提升,合成层非常消耗内存和GPU,

解决方案:

    给合成层一个大的z-index,避免隐式合成

浏览器优化

    浏览器有优化机制,层压缩机制: 多个渲染层同一个合成层重叠时，会自动将他们压缩到一起，避免“层爆炸”带来的损耗。

### 问题:

#### 1: z-index 大的元素一定在 z-index 小的元素的上面吗?

    不一定,元素要加上定位后,才会生效,在当前的层叠上下文中比较才有意义

#### 2:父元素的 z-index 怎样覆盖子元素的 z-index

将子元素的 z-index 设置为负数

### 总结:

合成层中的层是:可以被认为是真正物理上的层，浏览器把它独立出来，单独拿给 GPU 处理

渲染层: 层叠上下文的“层”,一个具有层叠上下文的元素就是一个渲染层

一个合成层可以包含多个渲染层
